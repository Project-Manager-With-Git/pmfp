package cli

import (
	"context"
	pb "$project_name/grpc_schema"
	"io"
	"log"
	"time"

	grpc "google.golang.org/grpc"
)

// Client pb的客户端类型
type Client struct {
	Address string
	conn    *grpc.ClientConn
	client  pb.RPCClient
}

//Handdler DoReqRes方法的通用处理函数类型
type Handdler func(c pb.RPCClient, ctx context.Context) (interface{}, error)

// New 创建客户端对象
func New(address string) (*Client, error) {
	var c Client
	conn, err := grpc.Dial(address, grpc.WithInsecure())
	if err != nil {
		return &c, err
	}
	client := pb.NewRPCClient(conn)
	c.Address = address
	c.conn = conn
	c.client = client
	return &c, err
}

//Close 客户端断开连接
func (client *Client) Close() {
	client.conn.Close()
}

//DoReqRes 请求-响应模式通用方法
func (client *Client) DoReqRes(handdler Handdler, timeout time.Duration) (interface{}, error) {
	// 设置请求上下文的过期时间
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	rs, err := handdler(client.client, ctx)
	return rs, err
}

//Square 请求-响应模板
func (client *Client) Square(x float64, timeout time.Duration) (float64, error) {
	res, err := client.DoReqRes(
		func(c pb.RPCClient, ctx context.Context) (interface{}, error) {
			rs, err := c.Square(ctx, &pb.Message{Message: x})
			return rs, err
		},
		timeout)
	if err != nil {
		return 0.0, err
	} else {
		return res.(*pb.Message).Message, nil
	}
}

//RangeSquare 请求-响应流模板
func (client *Client) RangeSquare(x float64, timeout time.Duration) chan float64 {
	outch := make(chan float64)
	ctx, cancel := context.WithTimeout(context.Background(), timeout)

	go func() {
		defer cancel()
		stream, err := client.client.RangeSquare(ctx, &pb.Message{Message: x})
		if err != nil {
			close(outch)
			return
		}
		for {
			result, err := stream.Recv()
			if err != nil {
				if err == io.EOF {
					close(outch)
					break
				} else {
					log.Fatalf("%v.RangeSquare(_) = _, %v", client, err)
				}
			} else {
				a := result.Message
				log.Println("get", a)
				outch <- a
			}
		}
	}()
	return outch
}

//SumSquare 请求流-响应模板
func (client *Client) SumSquare(ch chan float64, timeout time.Duration) (float64, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	resch := make(chan struct {
		err    error
		result float64
	})

	go func() {
		defer cancel()
		defer close(resch)
		stream, err := client.client.SumSquare(ctx)
		if err != nil {
			log.Fatalf("could not call: %v", err)
			return
		}
		for i := range ch {
			msg := pb.Message{Message: i}
			err := stream.Send(&msg)
			if err != nil {
				if err == io.EOF {
					break
				}
				log.Fatalf("%v.Send(%v) = %v", stream, msg, err)
			}
		}
		reply, err := stream.CloseAndRecv()
		resch <- struct {
			err    error
			result float64
		}{err, reply.Message}
	}()
	var res struct {
		err    error
		result float64
	}
	for ans := range resch {
		res = ans
	}
	return res.result, res.err
}

//StreamrangeSquare请求流-响应流模板
func (client *Client) StreamrangeSquare(inch chan float64, timeout time.Duration) (chan float64, error) {
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	outch := make(chan float64)
	stream, err := client.client.StreamrangeSquare(ctx)
	if err != nil {
		log.Fatalf("could not call: %v", err)
		close(outch)
		return outch, err
	}
	go func() {
		for i := range inch {
			stream.Send(&pb.Message{Message: i})
		}
		stream.CloseSend()
	}()

	go func() {
		defer cancel()
		defer close(outch)
		for {
			out, err := stream.Recv()
			if err != nil {
				if err == io.EOF {
					// read done.
					break

				} else {
					log.Fatalf("Failed to receive a note : %v", err)
					break
				}
			} else {
				outch <- out.Message
			}

		}
	}()
	return outch, err
}
