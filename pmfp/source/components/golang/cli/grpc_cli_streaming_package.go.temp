package cli

import (
    "context"
    pb "$project_name/grpc_schema"
    "io"
    "log"
    "time"

    grpc "google.golang.org/grpc"
)

// Client pb的客户端类型
type Client struct {
    Address string
    conn    *grpc.ClientConn
    client  pb.RPCClient
}

//Handdler DoReqRes方法的通用处理函数类型
type Handdler func(c pb.RPCClient, ctx context.Context) (interface{}, error)

// New 创建客户端对象
func New(address string) (*Client, error) {
    var c Client
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        return &c, err
    }
    client := pb.NewRPCClient(conn)
    c.Address = address
    c.conn = conn
    c.client = client
    return &c, err
}

//Close 客户端断开连接
func (client *Client) Close() {
    client.conn.Close()
}

//DoReqRes 请求-响应模式通用方法
func (client *Client) DoReqRes(handdler Handdler, timeout time.Duration) (interface{}, error) {
    // 设置请求上下文的过期时间
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()
    rs, err := handdler(client.client, ctx)
    return rs, err
}

//Square 请求-响应模板
func (client *Client) Square(x float64, timeout time.Duration) (float64, error) {
    res, err := client.DoReqRes(
        func(c pb.RPCClient, ctx context.Context) (interface{}, error) {
            rs, err := c.Square(ctx, &pb.Message{Message: x})
            return rs, err
        },
        timeout)
    if err != nil {
        return 0.0, err
    } else {
        return res.(*pb.Message).Message, nil
    }
}

//RangeSquare 请求-响应流模板
func (client *Client) RangeSquare(x float64, timeout time.Duration) chan float64 {
    outch := make(chan float64)
    ctx, cancel := context.WithTimeout(context.Background(), timeout)

    go func() {
        defer cancel()
        stream, err := client.client.RangeSquare(ctx, &pb.Message{Message: x})
        if err != nil {
            close(outch)
            return
        }
        for {
            result, err := stream.Recv()
            if err != nil {
                if err == io.EOF {
                    close(outch)
                    break
                } else {
                    log.Fatalf("%v.RangeSquare(_) = _, %v", client, err)
                }
            } else {
                a := result.Message
                log.Println("get", a)
                outch <- a
            }
        }
    }()
    return outch
}

//SumSquare 请求流-响应模板
func (client *Client) SumSquare(ch chan float64, timeout time.Duration) (float64, error) {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    resch := make(chan struct {
        err    error
        result float64
    })

    go func() {
        defer cancel()
        defer close(resch)
        stream, err := client.client.SumSquare(ctx)
        if err != nil {
            log.Fatalf("could not call: %v", err)
            return
        }
        for i := range ch {
            msg := pb.Message{Message: i}
            err := stream.Send(&msg)
            if err != nil {
                if err == io.EOF {
                    break
                }
                log.Fatalf("%v.Send(%v) = %v", stream, msg, err)
            }
        }
        reply, err := stream.CloseAndRecv()
        resch <- struct {
            err    error
            result float64
        }{err, reply.Message}
    }()
    var res struct {
        err    error
        result float64
    }
    for ans := range resch {
        res = ans
    }
    return res.result, res.err
}

//StreamrangeSquare请求流-响应流模板
func (client *Client) StreamrangeSquare(inch chan float64, timeout time.Duration) (chan float64, error) {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    outch := make(chan float64)
    stream, err := client.client.StreamrangeSquare(ctx)
    if err != nil {
        log.Fatalf("could not call: %v", err)
        close(outch)
        return outch, err
    }
    go func() {
        for i := range inch {
            stream.Send(&pb.Message{Message: i})
        }
        stream.CloseSend()
    }()

    go func() {
        defer cancel()
        defer close(outch)
        for {
            out, err := stream.Recv()
            if err != nil {
                if err == io.EOF {
                    // read done.
                    break

                } else {
                    log.Fatalf("Failed to receive a note : %v", err)
                    break
                }
            } else {
                outch <- out.Message
            }

        }
    }()
    return outch, err
}
