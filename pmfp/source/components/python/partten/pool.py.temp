import abc
import collections
import contextlib
from typing import (
    overload,
    Any
)


class PoolAbc(abc.ABC):
    """池模式抽象类.

    池是用来统一管理一类对象的对象,

    在池模型中,对象是用来消耗的,空闲的对象放在池中,需要使用时从池子中取出,同时放入_used容器中.

    用好后则需要将_used中的对应的对象释放.

    publish:
        traget_class (class or factory): 用于生产目标对象的类或者工厂方法,只要返回的是对象即可
        args (Any): 生成对象的位置参数
        kwargs (Any): 生成对象的关键字参数

    protected:
        _pool (collections.deque): 长度限制为maxsize的双端队列,用于保存可用的对象
        _minsize (int): 允许的最小池大小.
        _acquiring (int): 捕捉中的对象数量
        _used (Set[obj]): 使用中的对象

    property:
        minsize (int): 池对象的最小大小
        maxsize (int): 池对象的最大大小
        freesize (int): 池对象当前的可用对象数量
        size (int): 池对象当前的总长度
    """

    def __init__(self, traget_class_or_factory: Any, *args, maxsize: int=10, minsize: int=0, **kwargs):
        """创建一个池对象.

        Args:
            traget_class_or_factory (Any): 用于生产目标对象的类或者工厂方法,只要返回的是对象即可
            maxsize (int, optional): Defaults to 10. 池的大小上限
            minsize (int, optional): Defaults to 0. 池的大小下限
            args/kwargs (Any): 用于创建池中对象的参数
        """

        # 池初始化大小判断参数
        assert isinstance(minsize, int) and minsize >= 0, (
            "minsize must be int >= 0", minsize, type(minsize))
        assert maxsize is not None, "Arbitrary pool size is disallowed."
        assert isinstance(maxsize, int) and maxsize > 0, (
            "maxsize must be int > 0", maxsize, type(maxsize))
        assert minsize <= maxsize, (
            "Invalid pool min/max sizes", minsize, maxsize)
        self.traget_class = traget_class_or_factory
        self.args = args
        self.kwargs = kwargs
        self._pool = collections.deque(maxlen=maxsize)
        self._minsize = minsize
        self._acquiring = 0
        self._used = set()

    def __repr__(self):
        return f'<{self.__class__.__name__} [size:[{self.minsize}:{self.maxsize}], free:{self.freesize}]>'

    @property
    def minsize(self):
        """Minimum pool size."""
        return self._minsize

    @property
    def maxsize(self):
        """Maximum pool size."""
        return self._pool.maxlen

    @property
    def freesize(self):
        """Current number of free connections."""
        return len(self._pool)

    @property
    def size(self):
        """Current pool size."""
        return self.freesize + len(self._used) + self._acquiring

    def _fill_free(self, *, override_min: bool):
        """将池填满."""
        while self.size < self.minsize:
            self._acquiring += 1
            try:
                obj = self.traget_class(*self.args, **self.kwargs)
                self._pool.append(obj)
            finally:
                self._acquiring -= 1
        if self.freesize:
            return
        if override_min:
            while not self._pool and self.size < self.maxsize:
                self._acquiring += 1
                try:
                    obj = self.traget_class(*self.args, **self.kwargs)
                    self._pool.append(obj)
                finally:
                    self._acquiring -= 1

    @abc.abstractmethod
    def acquire(self):
        """获取一个对象."""
        while True:
            self._fill_free(override_min=True)
            obj = self._pool.popleft()
            assert obj not in self._used, f"object {obj} is already uesd"
            self._used.add(obj)
            return obj

    @abc.abstractmethod
    def release(self, obj):
        """将对象从池中释放."""
        assert obj in self._used, f"object {obj} not in this pool"
        self._used.remove(obj)

    @abc.abstractmethod
    @contextlib.contextmanager
    def open(self):
        """使用上下文管理池子.

        从池子中取出一个对象,在上下文中用好后将对象释放

        """
        obj = self.acquire()
        yield obj
        self.release(obj)


class SimplePool(PoolAbc):
    """简易池类.

    池是用来统一管理一类对象的对象,

    在池模型中,对象是用来消耗的,空闲的对象放在池中,需要使用时从池子中取出,同时放入_used容器中.

    用好后则需要将_used中的对应的对象释放.

    用法:

    >>> class A:
    ...     def __init__(self,x):
    ...         self.x=x
    ...     def send(self,msg):
    ...         self.msg = msg

    >>> p = SimplePool(A,1)
    >>> with p.open() as aa:
    ...     print(aa.x)
    1

    publish:
        traget_class (class or factory): 用于生产目标对象的类或者工厂方法,只要返回的是对象即可
        args (Any): 生成对象的位置参数
        kwargs (Any): 生成对象的关键字参数

    property:
        minsize (int): 池对象的最小大小
        maxsize (int): 池对象的最大大小
        freesize (int): 池对象当前的可用对象数量
        size (int): 池对象当前的总长度
    """

    def acquire(self):
        """获取一个对象."""
        return super().acquire()

    def release(self, obj):
        """将对象从池中释放."""

        assert obj in self._used, f"object {obj} not in this pool"
        self._used.remove(obj)

    @contextlib.contextmanager
    def open(self):
        """使用上下文管理池子.

        从池子中取出一个对象,在上下文中用好后将对象释放

        """
        obj = self.acquire()
        yield obj
        self.release(obj)


if __name__ == '__main__':
    import doctest
    doctest.testmod()
