import os
import socket
import asyncio
import warnings
import contextlib
import multiprocessing
from ipaddress import ip_address
from typing import Optional, Any, Dict, Iterator
import grpc
from grpc_reflection.v1alpha import reflection
from grpc_health.v1 import _async as health
from grpc_health.v1 import health_pb2
from grpc_health.v1 import health_pb2_grpc
from schema_entry import EntryPoint
from .${service_name_lower}_pb2_grpc import ${service_name}Servicer, add_${service_name}Servicer_to_server
from .${service_name_lower}_pb2 import DESCRIPTOR, Message


class Handdler(${service_name}Servicer):
    def __init__(self, config: Dict[str, Any]):
        super().__init__()
        self.config = config

    async def Echo(self, request: Any, context: grpc.aio.ServicerContext) -> Any:
        return Message(Message=request.Message)


class AioServ(EntryPoint):
    """grpc的服务端启动入口."""
    schema = {
        "$schema": "http://json-schema.org/draft-07/schema#",
        "type": "object",
        "required": ["address", "log_level"],
        "properties": {
            "app_version": {
                "type": "string",
                "description": "application version"
            },
            "app_name": {
                "type": "string",
                "description": "application name"
            },
            "address": {
                "type": "string",
                "description": "service address",
                "default": "0.0.0.0:5000"
            },
            "log_level": {
                "type": "string",
                "description": "log level",
                "default": "DEBUG"
            },
            "workers": {
                "type": "integer",
                "description": "start processes,when <=0 will set as the host's core number",
                "default": 1
            }
        }
    }

    @contextlib.contextmanager
    def _reserve_port(self) -> Iterator[int]:
        """Find and reserve a port for all subprocesses to use."""
        config = self.config
        host, ports = config.get("address", "0.0.0.0:5000").split(":")
        port = int(ports)
        ip = ip_address(host)
        host = str(ip)
        sock = socket.socket(
            socket.AF_INET6 if ip.version == 6 else socket.AF_INET,
            socket.SOCK_STREAM
        )
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
        if sock.getsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT) == 0:
            raise RuntimeError("Failed to set SO_REUSEPORT.")
        sock.bind((host, port))
        try:
            yield sock.getsockname()[1]
        finally:
            sock.close()

    async def _run_singal_serv(self, config: Dict[str, Any], pid: Optional[int], bind_address: Optional[str] = None) -> None:
        grpc_serv = grpc.aio.server()
        handdler = Handdler(config)
        add_${service_name}Servicer_to_server(handdler, grpc_serv)

        # 健康检查
        health_servicer = health.HealthServicer()
        health_pb2_grpc.add_HealthServicer_to_server(health_servicer, grpc_serv)

        # 反射
        services = tuple(
            service.full_name
            for service in DESCRIPTOR.services_by_name.values()
        ) + (
            reflection.SERVICE_NAME,
            health.SERVICE_NAME
        )
        reflection.enable_server_reflection(services, grpc_serv)
        # 绑定端口
        if bind_address:
            grpc_serv.add_insecure_port(bind_address)
            warnings.warn(f"worker {pid} start @{bind_address}")
        else:
            addr = config.get("address", "localhost:5000")
            grpc_serv.add_insecure_port(addr)
            warnings.warn(f"grpc @process:{pid} start @{addr}")
        await grpc_serv.start()
        # 设置服务为健康
        overall_server_health = ""
        for service in services + (overall_server_health,):
            health_servicer.set(service, health_pb2.HealthCheckResponse.SERVING)
        await grpc_serv.wait_for_termination()

    def run_singal_serv(self, config: Dict[str, Any], bind_address: Optional[str] = None) -> None:
        pid = os.getpid()
        try:
            asyncio.run(self._run_singal_serv(config=config, pid=pid, bind_address=bind_address))
        except KeyboardInterrupt:
            if bind_address:
                warnings.warn(f"worker {pid} stoped")
            else:
                warnings.warn("grpc stoped")
        except Exception as e:
            raise e

    def run_mp_serv(self, worker_num: int) -> None:
        workers = []
        config = self.config
        try:
            with self._reserve_port() as port:
                bind_address = 'localhost:{}'.format(port)
                for _ in range(worker_num):
                    worker = multiprocessing.Process(
                        target=self.run_singal_serv,
                        kwargs={
                            "config": config,
                            "bind_address": bind_address
                        })
                    worker.start()
                    workers.append(worker)
                for worker in workers:
                    worker.join()
        except KeyboardInterrupt:
            warnings.warn("grpc workers stoping")
        except Exception as e:
            raise e

    def run_service(self) -> None:
        config = self.config
        workers = config.get("workers", 1)
        if workers <= 0:
            workers = multiprocessing.cpu_count()
        if workers == 1:
            self.run_singal_serv(config=config)
        else:
            try:
                self.run_mp_serv(worker_num=workers)
            except Exception as e:
                err = type(e)
                err_msg = str(e)
                warnings.warn(f"多进程执行失败,改为单进程执行: {err} with msg {err_msg}")
                self.run_singal_serv(config=config)


aio_server = AioServ()
