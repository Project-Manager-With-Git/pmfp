${package}
import (
	"fmt"
	"net"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"
	"time"

	log "github.com/Golang-Tools/loggerhelper"

	"github.com/liyue201/grpc-lb/common"
	"github.com/liyue201/grpc-lb/registry"
	zk "github.com/liyue201/grpc-lb/registry/zookeeper"

	grpc "google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/reflection"
	"google.golang.org/grpc/health"
	healthpb "google.golang.org/grpc/health/grpc_health_v1"
)

//Server grpc的服务器结构体
type Server struct {
	AppName                                 string   `json:"app_name,omitempty" jsonschema:"description=服务名"`
	AppVersion                              string   `json:"app_version,omitempty" jsonschema:"description=服务版本"`
	Address                                 string   `json:"address,omitempty" jsonschema:"description=服务的主机和端口"`
	LogLevel                                string   `json:"log_level,omitempty" jsonschema:"description=项目的log等级,enum=TRACE,enum=DEBUG,enum=INFO,enum=WARN,enum=ERROR"`
	ZookeeperURL                            []string `json:"zookeeper_url,omitempty" jsonschema:"description=负载均衡使用的zookeeper地址序列以逗号分隔"`
	BalanceWeight                           string   `json:"balance_weight,omitempty" jsonschema:"description=负载均衡的权重"`
	MaxRecvMsgSize                          int      `json:"max_rec_msg_size,omitempty" jsonschema:"description=允许接收的最大消息长度"`
	MaxSendMsgSize                          int      `json:"max_send_msg_size,omitempty" jsonschema:"description=允许发送的最大消息长度"`
	UseChannelz                             bool     `json:"use_channelz,omitempty" jsonschema:"description=是否使用channelz协助优化"`
	ServerCertPath                          string   `json:"server_cert_path ,omitempty" jsonschema:"description=使用TLS时服务端的证书位置"`
	ServerKeyPath                           string   `json:"server_key_path,omitempty" jsonschema:"description=使用TLS时服务端证书的私钥位置"`
	MaxConnectionIdle                       int      `json:"server_key_path,omitempty" jsonschema:"description=客户端连接的最大空闲时长"`
	MaxConnectionAge                        int      `json:"server_key_path,omitempty" jsonschema:"description=如果连接存活超过n则发送goaway"`
	MaxConnectionAgeGrace                   int      `json:"server_key_path,omitempty" jsonschema:"description=强制关闭连接之前允许等待的rpc在5秒内完成"`
	Pingduration                            int      `json:"server_key_path,omitempty" jsonschema:"description=空闲连接每隔n秒ping一次客户端已确保连接存活"`
	PingAckTimeout                          int      `json:"ping_ack_timeout,omitempty" jsonschema:"description=ping时长超过n则认为连接已死"`
	KeepaliveEnforcementMinTime             int      `json:"keepalive_enforement_min_time,omitempty" jsonschema:"description=如果客户端超过每n秒ping一次则终止连接"`
	KeepaliveEnforcementPermitWithoutStream bool     `json:"keepalive_enforement_permit_without_stream,omitempty" jsonschema:"description=即使没有活动流也允许ping"`

	service       *registry.ServiceInfo
	healthservice *health.Server
	registrar     *zk.Registrar
}

//Schema 参数的校验信息
func (s *Server) Schema() string {
	schema := `{
		"description": "server config",
		"type": "object",
		"required": [ "address","log_level"],
		"additionalProperties": false,
		"properties": {
			"app_name":{
				"type": "string",
				"description": "服务名"
			},
			"app_version":{
				"type": "string",
				"description": "服务版本"
			},
			"address": {
				"type": "string",
				"description": "服务的主机和端口"
			},
			"log_level":{
				"type": "string",
				"enum": ["TRACE","DEBUG","INFO","WARN","ERROR"],
				"description": "项目的log等级"
			},
			"zookeeper_url":{
				"type":"array",
				"items":{
					"type": "string"
				},
				"description": "负载均衡使用的zookeeper地址序列,以逗号分隔"
			},
			"balance_weight":{
				"type": "string",
				"description": "负载均衡的权重"
			}
		}
	}`
	return schema
}

//Main 服务的入口函数
func (s *Server) Main() {
	// 初始化log
	log.Init(s.LogLevel, log.Dict{
		"app_name":    s.AppName,
		"app_version": s.AppVersion,
	})
	log.Info("获得参数", nil, log.Dict{"ServiceConfig": s}, nil)
	s.Run()
}

//RunServer 启动服务
func (s *Server) RunServer() {
	lis, err := net.Listen("tcp", s.Address)
	if err != nil {
		log.Error("Failed to Listen", log.Dict{"error": err, "address": s.Address})
		os.Exit(1)
	}
	log.Info("Server Start", log.Dict{"address": s.Address})
	gs := grpc.NewServer()
	defer gs.Stop()
	healthcheck := health.NewServer()
	healthpb.RegisterHealthServer(gs, healthcheck)

	go func() {
		// asynchronously inspect dependencies and toggle serving status as needed
		next := healthpb.HealthCheckResponse_SERVING

		for {
			healthcheck.SetServingStatus(system, next)

			if next == healthpb.HealthCheckResponse_SERVING {
				next = healthpb.HealthCheckResponse_NOT_SERVING
			} else {
				next = healthpb.HealthCheckResponse_SERVING
			}

			time.Sleep(*sleep)
		}
	}()

	${registservice}(gs, s)
	reflection.Register(gs)
	err = gs.Serve(lis)
	if err != nil {
		log.Error("Failed to Serve", log.Dict{"error": err})
		os.Exit(1)
	}
}

//RegistService 注册服务到zookeeper
func (s *Server) RegistService() {
	if s.registrar != nil && s.service != nil {
		log.Warn("服务注册已经初始化")
		return
	}
	port := strings.Split(s.Address, ":")[1]
	addrs, err := net.InterfaceAddrs()

	if err != nil {
		log.Error("获取本地ip失败", log.Dict{"place": "RegistService", "err": err})
		os.Exit(1)
	}
	ip := ""
	for _, _ip := range addrs {
		IP := _ip.String()
		if strings.HasPrefix(IP, "172.16.1.") {
			if strings.Contains(IP, "/") {
				ip = strings.Split(IP, "/")[0]
			} else {
				ip = IP
			}
			break
		}
	}
	if ip == "" {
		log.Error("未找到ip", log.Dict{"place": "RegistService"})
		os.Exit(1)
	}
	hostname, err := os.Hostname()
	if err != nil {
		log.Error("获取本地容器hostname失败", log.Dict{"place": "RegistService", "err": err})
		os.Exit(1)
	}
	service := &registry.ServiceInfo{
		InstanceId: hostname,
		Name:       s.AppName,
		Version:    s.AppVersion,
		Address:    fmt.Sprintf("%s:%s", ip, port),
		Metadata:   metadata.Pairs(common.WeightKey, s.BalanceWeight),
	}
	log.Info("注册的服务", log.Dict{"service": *service})
	registrar, err := zk.NewRegistrar(
		&zk.Config{
			ZkServers:      s.ZookeeperURL,
			RegistryDir:    "/backend/services",
			SessionTimeout: time.Second,
		})
	if err != nil {
		log.Error("regist error", log.Dict{"err": err})
		os.Exit(1)
	}
	s.registrar = registrar
	s.service = service

}

//Run 执行grpc服务
func (s *Server) Run() {
	if len(s.ZookeeperURL) == 0 || s.ZookeeperURL == nil {
		s.RunServer()
	} else {
		s.RegistService()
		wg := sync.WaitGroup{}
		wg.Add(1)
		go func() {
			s.RunServer()
			wg.Done()
		}()

		wg.Add(1)
		go func() {
			s.registrar.Register(s.service)
			wg.Done()
		}()
		signalChan := make(chan os.Signal, 1)
		signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM)
		<-signalChan
		s.registrar.Unregister(s.service)
		// serv.Stop()
		wg.Wait()
	}
}
